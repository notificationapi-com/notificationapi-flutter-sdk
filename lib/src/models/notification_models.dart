// DO NOT EDIT THIS FILE UNLESS APIs HAVE BEEN UPDATED.

/// API endpoints available for NotificationAPI
class APIEndpoints {
  static const String us = 'https://api.notificationapi.com';
  static const String eu = 'https://api.eu.notificationapi.com';
  static const String ca = 'https://api.ca.notificationapi.com';
}

/// WebSocket endpoints available for NotificationAPI
class WSEndpoints {
  static const String us = 'https://ws.notificationapi.com';
  static const String eu = 'https://ws.eu.notificationapi.com';
  static const String ca = 'https://ws.ca.notificationapi.com';
}

/// Channel types for notifications
enum Channel {
  email('EMAIL'),
  inappWeb('INAPP_WEB'),
  sms('SMS'),
  call('CALL'),
  push('PUSH'),
  webPush('WEB_PUSH');

  const Channel(this.value);
  final String value;
}

/// Delivery options for different channels
enum DeliveryOption {
  off('off'),
  instant('instant'),
  hourly('hourly'),
  daily('daily'),
  weekly('weekly'),
  monthly('monthly');

  const DeliveryOption(this.value);
  final String value;
}

/// Push token providers
enum PushProvider {
  fcm('FCM'),
  apn('APN');

  const PushProvider(this.value);
  final String value;
}

/// Device information for push tokens
class Device {
  final String? appId;
  final String? adId;
  final String deviceId;
  final String? platform;
  final String? manufacturer;
  final String? model;

  Device({
    this.appId,
    this.adId,
    required this.deviceId,
    this.platform,
    this.manufacturer,
    this.model,
  });

  Map<String, dynamic> toJson() => {
        if (appId != null) 'app_id': appId,
        if (adId != null) 'ad_id': adId,
        'device_id': deviceId,
        if (platform != null) 'platform': platform,
        if (manufacturer != null) 'manufacturer': manufacturer,
        if (model != null) 'model': model,
      };
}

/// Push token information
class PushToken {
  final PushProvider type;
  final String token;
  final Device device;

  PushToken({required this.type, required this.token, required this.device});

  Map<String, dynamic> toJson() => {
        'type': type.value,
        'token': token,
        'device': device.toJson(),
      };
}

/// Web push subscription
class WebPushSubscription {
  final String endpoint;
  final Map<String, String> keys;

  WebPushSubscription({required this.endpoint, required this.keys});

  Map<String, dynamic> toJson() => {'endpoint': endpoint, 'keys': keys};
}

/// Web push token
class WebPushToken {
  final WebPushSubscription sub;

  WebPushToken({required this.sub});

  Map<String, dynamic> toJson() => {'sub': sub.toJson()};
}

/// User information
class User {
  final String id;
  final String? email;
  final String? number;
  final List<PushToken>? pushTokens;
  final List<WebPushToken>? webPushTokens;

  User({
    required this.id,
    this.email,
    this.number,
    this.pushTokens,
    this.webPushTokens,
  });

  Map<String, dynamic> toJson() => {
        'id': id,
        if (email != null) 'email': email,
        if (number != null) 'number': number,
        if (pushTokens != null)
          'pushTokens': pushTokens!.map((t) => t.toJson()).toList(),
        if (webPushTokens != null)
          'webPushTokens': webPushTokens!.map((t) => t.toJson()).toList(),
      };
}

/// In-app notification data
class InAppNotification {
  final String id;
  final String notificationId;
  final String? subNotificationId;
  final bool seen;
  final String title;
  final String? redirectURL;
  final String? imageURL;
  final String date;
  final Map<String, dynamic>? parameters;
  final int? expDate;
  final String? opened;
  final String? clicked;
  final String? archived;

  InAppNotification({
    required this.id,
    required this.notificationId,
    this.subNotificationId,
    required this.seen,
    required this.title,
    this.redirectURL,
    this.imageURL,
    required this.date,
    this.parameters,
    this.expDate,
    this.opened,
    this.clicked,
    this.archived,
  });

  factory InAppNotification.fromJson(Map<String, dynamic> json) {
    return InAppNotification(
      id: json['id'],
      notificationId: json['notificationId'],
      subNotificationId: json['subNotificationId'],
      seen: json['seen'] ?? false,
      title: json['title'],
      redirectURL: json['redirectURL'],
      imageURL: json['imageURL'],
      date: json['date'],
      parameters: json['parameters'],
      expDate: json['expDate'],
      opened: json['opened'],
      clicked: json['clicked'],
      archived: json['archived'],
    );
  }
}

/// Preference data
class Preference {
  final String notificationId;
  final Channel channel;
  final DeliveryOption delivery;
  final String? subNotificationId;

  Preference({
    required this.notificationId,
    required this.channel,
    required this.delivery,
    this.subNotificationId,
  });

  Map<String, dynamic> toJson() => {
        'notificationId': notificationId,
        'channel': channel.value,
        'delivery': delivery.value,
        if (subNotificationId != null) 'subNotificationId': subNotificationId,
      };
}

/// Notification configuration
class NotificationConfig {
  final String notificationId;
  final String title;
  final List<Channel> channels;

  NotificationConfig({
    required this.notificationId,
    required this.title,
    required this.channels,
  });

  factory NotificationConfig.fromJson(Map<String, dynamic> json) {
    return NotificationConfig(
      notificationId: json['notificationId'],
      title: json['title'],
      channels: (json['channels'] as List)
          .map((c) => Channel.values.firstWhere((ch) => ch.value == c))
          .toList(),
    );
  }
}

/// Sub notification information
class SubNotification {
  final String notificationId;
  final String subNotificationId;
  final String title;

  SubNotification({
    required this.notificationId,
    required this.subNotificationId,
    required this.title,
  });

  factory SubNotification.fromJson(Map<String, dynamic> json) {
    return SubNotification(
      notificationId: json['notificationId'],
      subNotificationId: json['subNotificationId'],
      title: json['title'],
    );
  }
}

/// Preferences response
class GetPreferencesResponse {
  final List<Preference> preferences;
  final List<NotificationConfig> notifications;
  final List<SubNotification> subNotifications;

  GetPreferencesResponse({
    required this.preferences,
    required this.notifications,
    required this.subNotifications,
  });

  factory GetPreferencesResponse.fromJson(Map<String, dynamic> json) {
    return GetPreferencesResponse(
      preferences: (json['preferences'] as List)
          .map(
            (p) => Preference(
              notificationId: p['notificationId'],
              channel: Channel.values.firstWhere(
                (c) => c.value == p['channel'],
              ),
              delivery: DeliveryOption.values.firstWhere(
                (d) => d.value == p['delivery'],
              ),
              subNotificationId: p['subNotificationId'],
            ),
          )
          .toList(),
      notifications: (json['notifications'] as List)
          .map((n) => NotificationConfig.fromJson(n))
          .toList(),
      subNotifications: (json['subNotifications'] as List)
          .map((s) => SubNotification.fromJson(s))
          .toList(),
    );
  }
}

/// User account metadata
class UserAccountMetadata {
  final String logo;
  final String environmentVapidPublicKey;
  final bool hasWebPushEnabled;

  UserAccountMetadata({
    required this.logo,
    required this.environmentVapidPublicKey,
    required this.hasWebPushEnabled,
  });

  factory UserAccountMetadata.fromJson(Map<String, dynamic> json) {
    return UserAccountMetadata(
      logo: json['logo'],
      environmentVapidPublicKey: json['environmentVapidPublicKey'],
      hasWebPushEnabled: json['hasWebPushEnabled'],
    );
  }
}

/// In-app notifications result with pagination
class GetInAppNotificationsResult {
  final List<InAppNotification> items;
  final bool hasMore;
  final String oldestReceived;

  GetInAppNotificationsResult({
    required this.items,
    required this.hasMore,
    required this.oldestReceived,
  });
}

/// Exception thrown by NotificationAPI service
class NotificationAPIException implements Exception {
  final String message;
  final int? statusCode;

  const NotificationAPIException(this.message, [this.statusCode]);

  @override
  String toString() {
    return statusCode != null
        ? 'NotificationAPIException($statusCode): $message'
        : 'NotificationAPIException: $message';
  }
}
